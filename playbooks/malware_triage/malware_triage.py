#!/usr/bin/env python
import logging
import datetime
import re

# This playbook is designed to ingest Windows Defender antivirus logs
def process(data, mydb):
    logging.basicConfig(filename='/soar/playbooks/daemon.log', encoding='utf-8', level=logging.DEBUG)
    # Validate that we are receiving a windows defender log
    if "SourceName" in data:
        if data["SourceName"].lower() != "microsoft-windows-windows defender":
            return # quit
    else:
        return # quit
    # Main event processing function. Access data with data["field"]
    if "Name" in data and "Category" in data and "ComputerName" in data and "Detection_Source" in data:
        malware=data["Name"].lower()
        computer=data["ComputerName"].lower()
        category=data["Category"].lower()
        source=data["Detection_Source"].lower()
        computer_exclusion = ['computer1', 'computer2']
        if any(sub in computer for sub in computer_exclusion):
            # Ignore computers we do not want to mitigate
            logging.info(str(datetime.datetime.now()) + ' Bypassing mitigation for ' + computer)
            return # Quit
        always_escalate = ['malware_definition1', 'malware_definition2', 'malware_definition3']
        if any(sub in malware for sub in always_escalate):
            # Always mitigate these types of threats
            logging.info(str(datetime.datetime.now()) + ' mitigating important threat ' + malware + ' on ' + computer)
            doc = {'type': 'winrmquarantine', 'read': 0, 'host': computer}
            mydb.insert(doc, "actions")
            return # Quit
        # List of important malware categories to act on
        escalate_malware = ['backdoor', 'virus', 'ransom', 'remote access', 'trojan', 'trojan dropper', 'hacktool']
        if any(sub == category for sub in escalate_malware):
            if "Path" in data:
                if re.match("^.*:_c:\\\\users\\\\.*\\\\downloads\\\\",data["Path"].lower()):
                    logging.info(str(datetime.datetime.now()) + ' ignoring malware ' + malware + ' in downloads folder on ' + computer)
                    return # Quit
                if re.match("^.*:_c:\\\\users\\\\.*\\\\documents\\\\",data["Path"].lower()):
                    logging.info(str(datetime.datetime.now()) + ' ignoring malware ' + malware + ' in documents folder on ' + computer)
                    return # Quit
                if data["Path"].startswith("file:_\\"):
                    # Ignore files that are on a network share
                    logging.info(str(datetime.datetime.now()) + ' ignoring malware ' + malware + ' in network folder on ' + computer)
                    return # Quit 
            # weekday 0=Monday, 1=Tuesday..Saturday=5, Sunday=6
            day=datetime.datetime.today().weekday()
            if day >= 5:
                # Run mitigations on weekends
                logging.info(str(datetime.datetime.now()) + ' mitigating threat ' + malware + ' on ' + computer + ' during weekend')
                doc = {'type': 'winrmquarantine', 'read': 0, 'host': computer}
                mydb.insert(doc, "actions")

            else:
                hour=datetime.datetime.now().hour
                if hour < 7 or hour > 17:
                    # Run mitigations after normal work hours
                    logging.info(str(datetime.datetime.now()) + ' mitigating threat ' + malware + ' on ' + computer + ' during non-work hours')
                    doc = {'type': 'winrmquarantine', 'read': 0, 'host': computer}
                    mydb.insert(doc, "actions")
                
            # Else, if specific malware, quarantine host now
            # Only act on malware with strong damage potential
        else:
            logging.info(str(datetime.datetime.now()) + ' ignoring less dangerous malware ' + malware + ' on ' + computer)

def init(mydb):
    # Set the event filter: not read & siem_category to monitor
    for x in mydb.query({"read":0, "siem_category": "malware"},"events"):
        try:
            process(x['data'], mydb) # process the event data
        except:
            logging.info(str(datetime.datetime.now()) + ' error processing event id ' + str(x['_id']))
        mydb.mark_read(x['_id'],"events") # mark the event as read
